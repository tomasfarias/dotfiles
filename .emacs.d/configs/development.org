# -*- mode: org; coding: utf-8; -*-
#+ TITLE: Emacs: Development configuration
#+ AUTHOR: Tomás Farías Santana

This literate configuration sets up Emacs as a fully-fledged IDE. Packages and settings will be customized to my current programming needs, so, for example, only major modes for programming languages I am currently working with will appear here.

* Magit
[[https://magit.vc/][Magit]] is a [[https://github.com/magit/transient][transient]]-powered [[https://www.git-scm.com/][git]] porcelain.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package magit
    :config
    ;; This will set the following keybinds:
    ;; "C-x g" for `magit-status'
    ;; "C-c g" for `magit-dispatch'
    ;; "C-c f" for `magit-file-dispatch'
    (setq magit-define-global-key-bindings 'recommended))

  (use-package pinentry
    :config
    (setf epg-pinentry-mode 'loopback)
    (pinentry-start))

  (use-package magit-todos
    :after (magit))

  (use-package forge
  :after magit)
#+END_SRC

* Eldoc
Bundled with Emacs, this minor mode can display documentation of symbols at point.
#+BEGIN_SRC emacs-lisp :results output silent
  (setq eldoc-print-after-edit nil) ;; Set to non-nil to show documentation only after some editing command.
  (setq eldoc-echo-area-use-multiline-p nil) ;; The number of lines in the echo area Eldoc is allowed to use for documentation.
  (setq eldoc-idle-delay 0.5)
  (global-eldoc-mode 0)
#+END_SRC

I also install [[https://github.com/casouri/eldoc-box][eldoc-box]] to display the documentation in a childframe.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package eldoc-box
    :custom
    (eldoc-box-hover-mode nil))
#+END_SRC

* Project management
[[https://github.com/bbatsov/projectile][Projectile]] allows navigating and managing projects. I setup automatic project discovery for anything in my development directory.
#+BEGIN_SRC emacs-lisp :results output silent
  (setq shell-file-name "/usr/bin/fish")

  (use-package projectile
    :diminish projectile-mode

    :bind-keymap
    ("C-c p" . projectile-command-map)

    :config
    (projectile-global-mode)
    (setq projectile-globally-ignored-directories '(".idea"
        				                  ".vscode"
        				                  ".ensime_cache"
        				                  ".eunit"
        				                  ".git"
        				                  ".hg"
        				                  ".fslckout"
        				                  "_FOSSIL_"
        				                  ".bzr"
        				                  "_darcs"
        				                  ".tox"
        				                  ".svn"
        				                  ".stack-work"
        				                  ".ccls-cache"
        				                  ".cache"
        				                  ".clangd"))
    (setq projectile-project-search-path '(("~/src/github.com/" . 2))))
#+END_SRC

Also, integrate projectile with consult. I override some of the projectile keybindings to use their consult variants.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package consult-projectile
    :after projectile
    :bind (:map projectile-command-map
                ("f" . consult-projectile-find-file)
                ("5 f" . consult-projectile-find-file-other-frame)
                ("4 f" . consult-projectile-find-file-other-window)
                ("p" . consult-projectile-switch-project)
                ("b" . consult-projectile-switch-to-buffer)
                ("d" . consult-projectile-find-dir)
                ("e" . consult-projectile-recentf)
                ("5 b" . consult-projectile-switch-to-buffer-other-frame)
                ("4 b" . consult-projectile-switch-to-buffer-other-window)))
#+END_SRC

* Treemacs
[[https://github.com/Alexander-Miller/treemacs][Treemacs]] mode for file and project exploring.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package treemacs
    :config
    (progn
      (treemacs-follow-mode t) ; Always move focus to current file
      (treemacs-filewatch-mode t) ; Watch files being displayed for changes and automatically refresh
      (treemacs-fringe-indicator-mode 'always)
      (pcase (cons (not (null (executable-find "git")))
                   (not (null treemacs-python-executable)))
        (`(t . t)
         (treemacs-git-mode 'deferred))
        (`(t . _)
         (treemacs-git-mode 'simple))))
    :bind (:map global-map
                ("<f8>" . treemacs)
                ("<f9>" . treemacs-add-and-display-current-project-exclusively)
                ("C-c t t" . treemacs)
                ("C-c t c" . treemacs-collapse-project)
                ("C-c t s" . treemacs-switch-workspace)
                ("C-c t r" . treemacs-remove-workspace)
                ("C-c t m" . treemacs-rename-workspace)
                ("C-c t w r" . treemacs-remove-project-from-workspace)
                ("C-c t w a" . treemacs-add-project-to-workspace)
                ("C-c t a" . treemacs-add-project-to-workspace)))

  (use-package treemacs-magit
    :after (treemacs magit))

  (use-package treemacs-projectile
    :after (treemacs projectile))

  (use-package treemacs-all-the-icons
    :after (treemacs))

  (use-package treemacs-icons-dired
    :after (treemacs)
    :hook (dired-mode . treemacs-icons-dired-enable-once))

  (with-eval-after-load 'doom-themes
    (doom-themes-treemacs-config))
#+END_SRC

* Formatting with Apheleia
I use [[https://github.com/radian-software/apheleia][apheleia]] as it allows running multiple formatting tools in sequence. As a prerequisite, we have to enable ~direnv-mode~ as many of the tools are shimmed by direnv.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package mise
    :hook (after-init . global-mise-mode)
    :config (add-to-list 'mise-auto-propagate-commands 'tomas/find-python-executable-in-virtual-environment))
#+END_SRC

For the setup, I use [[https://github.com/astral-sh/ruff][ruff]] for Python and the standard rustfmt for Rust:
#+BEGIN_SRC emacs-lisp :results output silent
  (defun tomas/find-python-executable-in-virtual-environment (executable)
    (interactive "sGet executable: ")
    "Return full path to EXECUTABLE inside virtualenv, or fallback to system version."
    (let* ((venv (getenv "VIRTUAL_ENV"))
           (venv-exe (and venv (expand-file-name (concat "bin/" executable) venv))))
      (if (and venv-exe (file-executable-p venv-exe))
          venv-exe
        (executable-find executable))))

  (use-package apheleia
    :config
    (setf apheleia-log-debug-info t) ; turn on for debugging formatting tools
    (apheleia-global-mode +1)
    (setf (alist-get 'rufffmt apheleia-formatters)
          '((tomas/find-python-executable-in-virtual-environment "ruff") "format" "--verbose" "--stdin-filename" filepath "-"))
    (setf (alist-get 'rufflint apheleia-formatters)
          ;; In case ruff cannot fix, then ignore and exit with 0
          '((tomas/find-python-executable-in-virtual-environment "ruff") "check" "--silent" "--fix" "--exit-zero" "--stdin-filename" filepath "--extend-select" "I" "-"))
    (setf (alist-get 'python-mode apheleia-mode-alist)
          '(rufffmt rufflint))
    (setf (alist-get 'python-ts-mode apheleia-mode-alist)
          '(rufffmt rufflint))
    (setf (alist-get 'rustfmt apheleia-formatters)
          '("rustfmt" "--edition" "2024" "--quiet" "--emit" "stdout"))
    (setf (alist-get 'rustic-mode apheleia-mode-alist)
          '(rustfmt))
    (setf (alist-get 'rustic-tsmode apheleia-mode-alist)
          '(rustfmt)))
#+END_SRC

* LSP
** LSP-mode
I have tried both Eglot and lsp-mode and, currently, the latter is more feature complete and, as such, fits my workflow better. The biggest reason is ~lsp-ui~ which allows peeking at definitions and references, while keeping the current buffer's context.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package lsp-mode
    :init
    (setq lsp-keymap-prefix "C-c l")

    :config
    (setq lsp-enable-snippet nil)
    (setq lsp-ruff-advertize-fix-all nil)
    (setq lsp-ruff-advertize-organize-imports nil)
    (setq lsp-signature-auto-activate nil)
    (setq lsp-signature-render-documentation nil)
    (setq lsp-log-io nil)
    (setq lsp-idle-delay 2)
    (setq lsp-diagnostic-clean-after-change t)

    :hook
    ((python-ts-mode . lsp-deferred)
     (python-mode . lsp-deferred)
     (rustic-mode . lsp-deferred)
     (typescript-mode . lsp-deferred)
     (typescript-ts-mode . lsp-deferred)
     (lsp-mode . lsp-enable-which-key-integration))

    :commands
    (lsp lsp-deferred))

  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))
  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
              (setcar orig-result command-from-exec-path))
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))
  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+END_SRC

However, most of ~lsp-ui~ features are quite noisy and distracting. In particular, anything in the sidelines is an immediate disable for me. The doc feature is nice to toggle, but not have it automatically enabled.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package lsp-ui
    :config
    ;; Anything in the sideline is too verbose and distracting
    (setq lsp-ui-sideline-show-diagnostics nil)
    (setq lsp-ui-sideline-show-hover nil)
    (setq lsp-ui-sideline-show-code-actions nil)
    ;; In contrast, peek is fantastic
    ;; I despise moving away from my buffer when using xref
    (setq lsp-ui-peek-enable t)
    (setq lsp-ui-peek-show-directory t)
    ;; Pulling up docs in the buffer is great, but only on command
    (setq lsp-ui-doc-enable t)
    (setq lsp-ui-doc-position 'at-point)
    (setq lsp-ui-doc-show-with-cursor t)
    (setq lsp-ui-doc-show-with-mouse nil)
    (setq lsp-ui-doc-delay 3.0)

    :bind (:map lsp-ui-mode-map
                ("M-." . lsp-ui-peek-find-definitions)
                ("M-?" . lsp-ui-peek-find-references))

    :commands lsp-ui-mode)
#+END_SRC

*** Extensions
#+BEGIN_SRC emacs-lisp :results output silent
    (use-package lsp-treemacs :commands lsp-treemacs-errors-list)
    (use-package consult-lsp
      :after (embark lsp-mode consult))

    (use-package flycheck
      :config
      (setq-default flycheck-disabled-checkers '(python-pycompile python-pylint python-mypy python-pyright python-ruff python-flake8))
      (setq flycheck-check-syntax-automatically '(save idle-change))

      :init (global-flycheck-mode))

    (use-package flycheck-pos-tip
      :after (flycheck))

    (with-eval-after-load 'flycheck
      (flycheck-pos-tip-mode))
    (with-eval-after-load 'lsp-mode
      (lsp-register-client (make-lsp-client
                            :new-connection (lsp-stdio-connection '("ty" "server"))
                            :major-modes '(python-mode python-ts-mode)
                            :priority 8
                            :add-on? t
                            :server-id 'ty-ls)))

  ;; (use-package lsp-pyright
  ;;   :custom (lsp-pyright-langserver-command "basedpyright")
  ;;   (lsp-pyright-disable-tagged-hints t)
  ;;   (lsp-pyright-type-checking-mode t)
  ;;   (lsp-pyright-basedpyright-inlay-hints-variable-types nil)
  ;;   (lsp-pyright-basedpyright-inlay-hints-call-argument-names nil)
  ;;   (lsp-pyright-basedpyright-inlay-hints-function-return-types nil)
  ;;   (lsp-pyright-basedpyright-inlay-hints-generic-types nil)
  ;;   (lsp-pyright-disable-organize-imports t)
  ;;   :hook (python-mode . (lambda ()
  ;;                           (require 'lsp-pyright)
  ;;                           (lsp-deferred))))  ; or lsp-deferred
#+END_SRC

*** Performance
#+BEGIN_SRC emacs-lisp :results output silent
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 4096 1024)) ;; 4mb
#+END_SRC

* Programming
Before going into language specific modes, we tell Emacs to prefer tree-sitter modes for all of them:
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package emacs
    :config
    ;; You'll want to run the command `M-x treesit-install-language-grammar' before editing.
    (setq major-mode-remap-alist
          '((yaml-mode . yaml-ts-mode)
            (bash-mode . bash-ts-mode)
            (typescript-mode . typescript-ts-mode)
            (json-mode . json-ts-mode)
            (css-mode . css-ts-mode)
            (python-mode . python-ts-mode))))
#+END_SRC

** Tree-sitter grammars
#+BEGIN_SRC emacs-lisp :results output silent
  (defun tomas/setup-install-grammars ()
    "Install Tree-sitter grammars if they are absent."
    (interactive)
    (dolist (grammar
             ;; Note the version numbers. These are the versions that
             ;; are known to work with Combobulate *and* Emacs.
             '((css . ("https://github.com/tree-sitter/tree-sitter-css" "v0.20.0"))
               (go . ("https://github.com/tree-sitter/tree-sitter-go" "v0.20.0"))
               (html . ("https://github.com/tree-sitter/tree-sitter-html" "v0.20.1"))
               (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript" "v0.20.1" "src"))
               (json ("https://github.com/tree-sitter/tree-sitter-json" "v0.20.2"))
               (markdown . ("https://github.com/ikatyang/tree-sitter-markdown" "v0.7.1"))
               (python . ("https://github.com/tree-sitter/tree-sitter-python" "v0.20.4"))
               (rust . ("https://github.com/tree-sitter/tree-sitter-rust" "v0.21.2"))
               (toml . ("https://github.com/tree-sitter/tree-sitter-toml" "v0.5.1"))
               (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "tsx/src"))
               (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "typescript/src"))
               (yaml . ("https://github.com/ikatyang/tree-sitter-yaml" "v0.5.0"))))
      (add-to-list 'treesit-language-source-alist grammar)
      ;; Only install `grammar' if we don't already have it
      ;; installed. However, if you want to *update* a grammar then
      ;; this obviously prevents that from happening.
      (unless (treesit-language-available-p (car grammar))
        (treesit-install-language-grammar (car grammar)))))

  (dolist (mapping
           '((python-mode . python-ts-mode)
             (css-mode . css-ts-mode)
             (typescript-mode . typescript-ts-mode)
             (js2-mode . js-ts-mode)
             (bash-mode . bash-ts-mode)
             (conf-toml-mode . toml-ts-mode)
             (go-mode . go-ts-mode)
             (css-mode . css-ts-mode)
             (json-mode . json-ts-mode)
             (js-json-mode . json-ts-mode)))
    (add-to-list 'major-mode-remap-alist mapping))
  (tomas/setup-install-grammars)
#+END_SRC

** Treesit fold
Code folding built on tree-sitter.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package treesit-fold
    :straight (treesit-fold :type git :host github :repo "emacs-tree-sitter/treesit-fold"))
#+END_SRC

** Combobulate
Structured editing and movement powered by tree-sitter.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package combobulate
      :custom (combobulate-key-prefix "C-c b")
      :straight (:type git :host github :repo "mickeynp/combobulate" :branch "master")
      :hook ((prog-mode . combobulate-mode)))
#+END_SRC

** File formats
Major modes for some common file formats generally used for READMEs or configurations.

*** Markdown
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package markdown-mode
    :mode ("\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))

  (use-package poly-markdown
    :config (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode)))
#+END_SRC

*** YAML
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package yaml-mode
    :mode ("\\.yml\\'" . yaml-mode)
    ("\\.yaml\\'" . yaml-mode))
#+END_SRC

*** JSON
#+BEGIN_SRC emacs-lisp :results output silent
(use-package json-mode)
#+END_SRC

** Python
This just disables the very annoying documentation that pops-up in the minibuffer while typing. If I need documentation I can request it with ~C-c h~, otherwise it's very distracting having it pop-up while typing.
#+BEGIN_SRC emacs-lisp :results output silent
  ;; (use-package python
  ;;   :if (featurep 'lsp-mode)
  ;;   :config
  ;;   (fmakunbound 'lsp-signature-activate)
  ;;   (defun lsp-signature-activate ()
  ;;     (message nil)))
#+END_SRC

** Rust
[[https://github.com/brotzeit/rustic?tab=readme-ov-file#intro][Rustic]] is built on top of [[https://github.com/rust-lang/rust-mode][rust-mode]] to extend with LSP integration.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package rust-mode
    :init
    (setq rust-mode-treesitter-derive t))

  (use-package rustic
    :after (rust-mode)
    :config
    (setq
     rustic-lsp-client 'lsp-mode
     ;; Let apheleia take care of format.
     rustic-format-trigger 'nil))
#+END_SRC

** Terraform
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package terraform-mode
    :mode
    ("\\.tf" . terraform-mode)

    :config
    (setq terraform-indent-level 2)
    (setq terraform-format-on-save t))
#+END_SRC

** Typescript
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package typescript-ts-mode
    :mode ("\\.tsx?\\'")
    :config
    (setq typescript-ts-mode-indent-offset 4)
    (setq typescript-mode-indent-offset 4))
#+END_SRC

* Terminal emulator: Eat
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package eat
    :straight (:type git
               :host codeberg
               :repo "akib/emacs-eat"
               :files ("*.el" ("term" "term/*.el") "*.texi"
                       "*.ti" ("terminfo/e" "terminfo/e/*")
                       ("terminfo/65" "terminfo/65/*")
                       ("integration" "integration/*")
                       (:exclude ".dir-locals.el" "*-tests.el")))

    :hook
    (eshell-load-hook . eat-eshell-mode) ;; Run Eat inside Eshell.
    (eshell-load-hook . eat-eshell-visual-command-mode)) ;; Run visual commands with Eat instead of Term.
#+END_SRC

* Extensions
** Rainbow delimiters
Highlight brackets in different colors according to depth. The faces ~rainbow-delimiters-depth-N-face~ (where ~N~ is 1-9),
~rainbow-delimiters-unmatched-face~ and ~rainbow-delimiters-unmatched-face~ can be customized to set the color.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package rainbow-delimiters)
#+END_SRC

** Highlight indentation guides
Helps keeping track of current indentation level when reviewing highly nested code. Nested code should be a code smell, so better to avoid it, but it's not always possible.
#+BEGIN_SRC emacs-lisp :results output silent
  (use-package highlight-indent-guides
    :custom (highlight-indent-guides-method 'character)
    (highlight-indent-guides-auto-character-face-perc nil)
    (highlight-indent-guides-auto-enabled nil)
    :config (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
    (set-face-background 'highlight-indent-guides-odd-face "darkgray")
    (set-face-background 'highlight-indent-guides-even-face "dimgray")
    (set-face-foreground 'highlight-indent-guides-character-face "dimgray"))

#+END_SRC
